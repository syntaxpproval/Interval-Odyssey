# Development Notes - February 8, 2025 (Part 4)

## Pattern B Save/Load Investigation Summary

### Current Problem State
1. Base Issue: Pattern B initialization and state management
2. Recent Progress: 
   - Eliminated initial "junk data" issues
   - Both patterns are now editable
   - Current problem: Patterns are mirroring each other (changes in one reflect in the other)

### What We Know Works
1. CLEAR command from menu always fixes Pattern B
2. LOAD command works when:
   - Loading a previously saved pattern
   - Loading a blank pattern (acts like CLEAR)
3. clear_current_pattern() function works correctly when called through menu

### What We've Tried
1. Initialization approaches:
   - Pre-initializing both bank storages
   - Forcing CLEAR during initialization
   - Explicit bank existence flags

2. Bank switching strategies:
   - Clean initialization when switching to Bank B
   - Storage-based switching
   - Channel-only switching

3. Debug findings:
   - Initially saw 42:42:42:42 pattern indicating memory corruption
   - Storage was showing corruption before bank switch
   - Bank B's storage was getting improper initialization

### Current Understanding
1. Memory Model:
   - Both banks share sequencer.channels structure
   - Each bank has its own storage in bank_data.storage
   - Bank switching should manage state between active channels and storage

2. Key Functions:
   ```c
   clear_current_pattern() // Works reliably through menu
   switch_bank()          // Manages bank switching and state
   init_sequencer()       // Initial setup of all structures
   ```

### Tomorrow's Investigation Path
1. Focus on separating bank states:
   - Verify storage structures aren't being shared
   - Ensure clean separation between active channels
   - Consider redesigning bank switching mechanism

2. Questions to Answer:
   - Why does menu CLEAR work but initialization CLEAR doesn't?
   - What's different about storage handling between banks?
   - Are we properly managing the active channels during bank switch?

3. Potential Solutions to Try:
   - Implement complete state separation
   - Redesign storage management
   - Consider alternative bank switching mechanism

### Current Code State
Last implemented changes:
```c
// In init_sequencer():
memset(&sequencer, 0, sizeof(SEQUENCER_DATA));
sequencer.bank_data.storage.bank_a_exists = 0;
sequencer.bank_data.storage.bank_b_exists = 0;

// In switch_bank():
static void switch_bank(BANK_ID new_bank) {
    BANK_ID old_bank = sequencer.bank_data.current_bank;
    sequencer.bank_data.current_bank = new_bank;
    if(new_bank == BANK_B && !sequencer.bank_data.storage.bank_b_exists) {
        clear_current_pattern();
    }
    update_pattern_display();
    sequencer.needs_redraw = 1;
}
```

### Next Steps
1. Implement proper state separation between banks
2. Review CLEAR implementation for insights
3. Consider restructuring bank storage mechanism
4. Test each bank's independence after changes

## Notes
- Keep all debug statements for tomorrow
- Consider adding more visual feedback during bank operations
- Document any pattern behavior changes immediately
